local id = game.PlaceId  -- Gets the current game ID

if id == 10449761463 then
    Tsb = true
else
    loadstring(game:HttpGet("https://rawscripts.net/raw/Xam-Vai-Cu-Ra-Day-La-Code-Sai-Game-Khong-Kick-Nha"))()
end

Tsb = false

if game.PlaceId == 10449761463 then
    Tsb = true
end

local CoreGui = game:GetService("StarterGui")
CoreGui:SetCore("SendNotification", {
    Title = "Support",
    Text = "Strongest battegourds",
    Icon = "rbxassetid://",
    Duration = math.huge,
    Callback = AllowRunServiceBind,
    Button1 = "Jot it",
})

function fly()
        local mouse=game:GetService("Players").LocalPlayer:GetMouse''
        localplayer=game:GetService("Players").LocalPlayer
        game:GetService("Players").LocalPlayer.Character:WaitForChild("HumanoidRootPart")
        local torso = game:GetService("Players").LocalPlayer.Character.HumanoidRootPart
        local speedSET=25
        local keys={a=false,d=false,w=false,s=false}
        local e1
        local e2
        local function start()
            local pos = Instance.new("BodyPosition",torso)
            local gyro = Instance.new("BodyGyro",torso)
            pos.Name="EPIXPOS"
            pos.maxForce = Vector3.new(math.huge, math.huge, math.huge)
            pos.position = torso.Position
            gyro.maxTorque = Vector3.new(9e9, 9e9, 9e9)
            gyro.CFrame = torso.CFrame
            repeat
                    wait()
                    localplayer.Character.Humanoid.PlatformStand=true
                    local new=gyro.CFrame - gyro.CFrame.p + pos.position
                    if not keys.w and not keys.s and not keys.a and not keys.d then
                    speed=1
                    end
                    if keys.w then
                    new = new + workspace.CurrentCamera.CoordinateFrame.lookVector * speed
                    speed=speed+speedSET
                    end
                    if keys.s then
                    new = new - workspace.CurrentCamera.CoordinateFrame.lookVector * speed
                    speed=speed+speedSET
                    end
                    if keys.d then
                    new = new * CFrame.new(speed,0,0)
                    speed=speed+speedSET
                    end
                    if keys.a then
                    new = new * CFrame.new(-speed,0,0)
                    speed=speed+speedSET
                    end
                    if speed>speedSET then
                    speed=speedSET
                    end
                    pos.position=new.p
                    if keys.w then
                    gyro.CFrame = workspace.CurrentCamera.CoordinateFrame*CFrame.Angles(-math.rad(speed*15),0,0)
                    elseif keys.s then
                    gyro.CFrame = workspace.CurrentCamera.CoordinateFrame*CFrame.Angles(math.rad(speed*15),0,0)
                    else
                    gyro.CFrame = workspace.CurrentCamera.CoordinateFrame
                    end
            until not Fly
            if gyro then
                    gyro:Destroy()
            end
            if pos then
                    pos:Destroy()
            end
            flying=false
            localplayer.Character.Humanoid.PlatformStand=false
            speed=0
        end
        e1=mouse.KeyDown:connect(function(key)
            if not torso or not torso.Parent then
                    flying=false e1:disconnect() e2:disconnect() return
            end
            if key=="w" then
                keys.w=true
            elseif key=="s" then
                keys.s=true
            elseif key=="a" then
                keys.a=true
            elseif key=="d" then
                keys.d=true
            end
        end)
        e2=mouse.KeyUp:connect(function(key)
            if key=="w" then
                keys.w=false
            elseif key=="s" then
                keys.s=false
            elseif key=="a" then
                keys.a=false
            elseif key=="d" then
                keys.d=false
            end
        end)
        start()
    end

local Playerlist = {}
function Update2()
    for i,v in pairs(game:GetService("Players"):GetChildren()) do
        table.insert(Playerlist,v.Name)
    end   
end

Update2()

local Fluent = loadstring(game:HttpGet("https://raw.githubusercontent.com/Tunguyen1441/Ui_Libbary//main/AmworkGay(Ui).txt"))()
local Savethame = loadstring(game:HttpGet("https://raw.githubusercontent.com/violin-suzutsuki/LinoriaLib/refs/heads/main/addons/ThemeManager.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/violin-suzutsuki/LinoriaLib/refs/heads/main/addons/SaveManager.lua"))()

local Window = Library:CreateWindow({
    Title = 'Rework | '.. game:GetService("MarketplaceService"):GetProductInfo(game.PlaceId).Name.. ' | Mera Hub',
    Center = true,
    AutoShow = true,
    TabPadding = 8,
    MenuFadeTime = 0
})

----NotifyFps---
local Tabs = {
    -- Creates a new tab titled Main
    Tab3 = Window:AddTab('Rework'),
    Main = Window:AddTab('Function'),
    Tab2 = Window:AddTab('Game Mod'),
}

local FrameTimer = tick()
local FrameCounter = 0;
local FPS = 60;

local WatermarkConnection = game:GetService('RunService').RenderStepped:Connect(function()
    FrameCounter += 1;

    if (tick() - FrameTimer) >= 1 then
        FPS = FrameCounter;
        FrameTimer = tick();
        FrameCounter = 0;
    end;

    Library:SetWatermark(('LinoriaLib demo | %s fps | %s ms'):format(
        math.floor(FPS),
        math.floor(game:GetService('Stats').Network.ServerStatsItem['Data Ping']:GetValue())
    ));
end);
----

---TabRework---
local LeftGroupBox = Tabs.Tab3:AddLeftGroupbox('Rework')

LeftGroupBox:AddLabel('User | ' ..game.Players.LocalPlayer.DisplayName.. '')
LeftGroupBox:AddLabel('Rework | Safe ')
local LeftGroupBox = Tabs.Tab3:AddLeftGroupbox('Add')
LeftGroupBox:AddLabel('Inf Jump')
------

local TabBox = Tabs.Main:AddLeftTabbox() -- Add Tabbox on left side

local Tab1 = TabBox:AddTab('Main')
local Tab2 = TabBox:AddTab('Tab 2')

Tab1:AddToggle('MyToggle', {
	Text = 'Farm Player',
	Default = false,
	Tooltip = 'This is a tooltip', -- Information shown when you hover over the toggle

	Callback = function(Value)
		AutoFarmPlayer = Value
	end
})

Tab1:AddToggle('MyToggle', {
	Text = 'Farm Trading Zummy',
	Default = false,
	Tooltip = 'This is a tooltip', -- Information shown when you hover over the toggle

	Callback = function(Value)
		AutoFarmWeakestDummy = Value
	end
})

Tab1:AddToggle('MyToggle', {
	Text = 'Farm Crab Real',
	Default = false,
	Tooltip = 'This is a tooltip', -- Information shown when you hover over the toggle

	Callback = function(Value)
		AutoFarmCrabBossReal = Value
	end
})

Tab2:AddDropdown('MyDropdown', {
    Values = Playerlist,
    Default = "", -- number index of the value / string
    Multi = false, -- true / false, allows multiple choices to be selected

    Text = 'Slect Player',
    Tooltip = 'This is a tooltip', -- Information shown when you hover over the dropdown

    Callback = function(Value)
        print('[cb] Dropdown got changed. New value:', Value)
    end
})

Options.MyDropdown:SetValue('nill')

Options.MyDropdown:OnChanged(function(Value)
    SelectPlayer = Value
end)

Tab2:AddToggle('MyToggle', {
	Text = 'Teleport',
	Default = false,
	Tooltip = 'This is a tooltip', -- Information shown when you hover over the toggle

	Callback = function(Value)
		TeleportPlayer = Value
	end
})

local LeftGroupBox = Tabs.Main:AddLeftGroupbox('Other')

LeftGroupBox:AddLabel('Safe Will work properly')

LeftGroupBox:AddToggle('MyToggle', {
	Text = 'Safe | Antidie',
	Default = false,
	Tooltip = 'This is a tooltip', -- Information shown when you hover over the toggle

	Callback = function(Value)
		AutoSafe = Value
	end
})

LeftGroupBox:AddToggle('MyToggle', {
	Text = 'AutoUseUltimate',
	Default = false,
	Tooltip = 'This is a tooltip', -- Information shown when you hover over the toggle

	Callback = function(Value)
		AutoUseUltimate = Value
	end
})

local LeftGroupBox = Tabs.Main:AddLeftGroupbox('Player')

LeftGroupBox:AddToggle('MyToggle', {
	Text = 'InfiniteJump',
	Default = false,
	Tooltip = 'This is a tooltip', -- Information shown when you hover over the toggle

	Callback = function(Value)
		InfiniteJump = Value
	end
})

LeftGroupBox:AddToggle('MyToggle', {
	Text = 'Fly',
	Default = false,
	Tooltip = 'This is a tooltip', -- Information shown when you hover over the toggle

	Callback = function(Value)
		Flyyy = Value
	end
})


local TabBox = Tabs.Main:AddRightTabbox()

local Tab1 = TabBox:AddTab('Setting')
local Tab2 = TabBox:AddTab('Skill)

Tab1:AddDropdown('MyDropdown', {
	Values = { 'Behind', 'Below', 'Upper' },
	Default = "", -- number index of the value / string
	Multi = false, -- true / false, allows multiple choices to be selected

	Text = 'Method Farm',
	Tooltip = 'This is a tooltip', -- Information shown when you hover over the dropdown

	Callback = function(Value)
		print('[cb] Dropdown got changed. New value:', Value)
	end
})

Options.MyDropdown:SetValue('Behind')

Options.MyDropdown:OnChanged(function(e)
    MethodFarm = e
end)

Tab1:AddSlider('MySlider', {
    Text = 'Distance Farm',
    Default = 2,
    Min = 0,
    Max = 35,
    Rounding = 1,
    Compact = false,

    Callback = function(Value)
        DistanceFarm = Value
    end
})

Tab2:AddToggle('MyToggle', {
	Text = 'Skill 1',
	Default = false,
	Tooltip = 'This is a tooltip', -- Information shown when you hover over the toggle

	Callback = function(Value)
		Skill1 = Value
	end
})

Tab2:AddToggle('MyToggle', {
	Text = 'Skill 2',
	Default = false,
	Tooltip = 'This is a tooltip', -- Information shown when you hover over the toggle

	Callback = function(Value)
		Skill2 = Value
	end
})

Tab2:AddToggle('MyToggle', {
	Text = 'Skill 3',
	Default = false,
	Tooltip = 'This is a tooltip', -- Information shown when you hover over the toggle

	Callback = function(Value)
		Skill3 = Value
	end
})

Tab2:AddToggle('MyToggle', {
	Text = 'Skill 4',
	Default = false,
	Tooltip = 'This is a tooltip', -- Information shown when you hover over the toggle

	Callback = function(Value)
		Skill4 = Value
	end
})

local LeftGroupBox = Tabs.Tab2:AddLeftGroupbox('Esp')

local MyButton = LeftGroupBox:AddButton({
    Text = 'Mod | Skill Sukuna',
    Func = function()
        loadstring(game:HttpGet"https://raw.githubusercontent.com/h8h88/hubfr/main/hubfr")()
    end,
    DoubleClick = false,
    Tooltip = 'This is the main button'
})

spawn(function()
        pcall(function()
            game:GetService("RunService").Stepped:Connect(function()
                  if AutoFarmPlayer or AutoFarmWeakestDummy or AutoFarmCrabBossReal or AutoFarmSelectPlayer then
                     if not game.Players.LocalPlayer.Character.HumanoidRootPart:FindFirstChild("BodyClip") then
                        local Noclip = Instance.new("BodyVelocity")
                        Noclip.Name = "BodyClip"
                        Noclip.Parent = game.Players.LocalPlayer.Character.HumanoidRootPart
                        Noclip.MaxForce = Vector3.new(100000,100000,100000)
                        Noclip.Velocity = Vector3.new(0,0,0)
                     end
                  else	
                      game.Players.LocalPlayer.Character.HumanoidRootPart:FindFirstChild("BodyClip"):Destroy()
                  end
            end)
        end)
    end)

spawn(function()
        pcall(function()
            game:GetService("RunService").Stepped:Connect(function()
                if AutoFarmPlayer or AutoFarmWeakestDummy or AutoFarmCrabBossReal or AutoFarmSelectPlayer then
                    for _, v in pairs(game:GetService("Players").LocalPlayer.Character:GetDescendants()) do
                        if v:IsA("BasePart") then
                            v.CanCollide = true
                        else
                            v.CanCollide = false
                        end
                    end
                end
            end)
        end)
    end)

spawn(function()
while wait() do
if AutoFarmPlayer then
pcall(function()
-- Script to teleport to a player, and when that player dies, teleport to another player

local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer

-- Maximum distance to consider a player nearby
local maxDistance = math.huge -- you can adjust this value

-- Function to teleport to another player's position
local function teleportToPlayer(player)
    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        if MethodFarm == "Behind" then
            localPlayer.Character.HumanoidRootPart.CFrame = player.Character.HumanoidRootPart.CFrame * CFrame.new(0,0,DistanceFarm) * CFrame.Angles(math.rad(0),0,0)
        elseif MethodFarm == "Below" then
            localPlayer.Character.HumanoidRootPart.CFrame = player.Character.HumanoidRootPart.CFrame * CFrame.new(0,-DistanceFarm,0) * CFrame.Angles(math.rad(90),0,0)
        elseif MethodFarm == "Upper" then
            localPlayer.Character.HumanoidRootPart.CFrame = player.Character.HumanoidRootPart.CFrame * CFrame.new(0,DistanceFarm,0) * CFrame.Angles(math.rad(-90),0,0)
        else
            localPlayer.Character.HumanoidRootPart.CFrame = player.Character.HumanoidRootPart.CFrame * CFrame.new(0,0,DistanceFarm) * CFrame.Angles(math.rad(0),0,0)
        end
        local args = {
    [1] = {
        ["Mobile"] = true,
        ["Goal"] = "LeftClick"
    }
}

game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))
        if Skill1 then
        game:service('VirtualInputManager'):SendKeyEvent(true, "One", false, game)
        game:service('VirtualInputManager'):SendKeyEvent(false, "One", false, game)
        end
        if Skill2 then
        game:service('VirtualInputManager'):SendKeyEvent(true, "Two", false, game)
        game:service('VirtualInputManager'):SendKeyEvent(false, "Two", false, game)
        end
        if Skill3 then
        game:service('VirtualInputManager'):SendKeyEvent(true, "Three", false, game)
        game:service('VirtualInputManager'):SendKeyEvent(false, "Three", false, game)
        end
        if Skill4 then
        game:service('VirtualInputManager'):SendKeyEvent(true, "Four", false, game)
        game:service('VirtualInputManager'):SendKeyEvent(false, "Four", false, game)
        end
        if AutoUseUltimate then
        game:service('VirtualInputManager'):SendKeyEvent(true, "G", false, game)
        game:service('VirtualInputManager'):SendKeyEvent(false, "G", false, game)
        end
        if AutoSafe then
        if game.Players.LocalPlayer.Character.Humanoid.Health <= 60 then
           game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(1023.8338012695312, 439.51055908203125, -1324.156494140625)
        end
        end
    end
end

-- Function to get the nearest player
local function getNearestPlayer()
    local closestPlayer = nil
    local shortestDistance = math.huge

    for _, player in pairs(Players:GetPlayers()) do
        if player ~= localPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local distance = (localPlayer.Character.HumanoidRootPart.Position - player.Character.HumanoidRootPart.Position).Magnitude
            if distance < shortestDistance and distance <= maxDistance then
                shortestDistance = distance
                closestPlayer = player
            end
        end
    end

    return closestPlayer
end

-- Function to check if a player is dead
local function isPlayerDead(player)
    return player.Character == nil or player.Character.Humanoid.Health <= 0
end

-- Main function to teleport, check state, and teleport to another player if current one dies
local function teleporter()
    while true do
        local nearestPlayer = getNearestPlayer()
        if nearestPlayer then
            teleportToPlayer(nearestPlayer)
            while nearestPlayer and not isPlayerDead(nearestPlayer) do
                wait(0) -- Adjust the time to check the dead state
            end
        end
        wait(0) -- Wait a short time before finding another player
    end
end

-- Start the teleporter
spawn(teleporter)

if AutoFarmPlayer == false then
   game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame
end
end)
end
end
end)

spawn(function()
while wait() do
if AutoFarmSelectPlayer then
pcall(function()
if MethodFarm == "Behind" then
game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = game:GetService("Players")[SelectPlayer].Character.HumanoidRootPart.CFrame * CFrame.new(0,0,DistanceFarm) * CFrame.Angles(math.rad(0),0,0)
elseif MethodFarm == "Below" then
game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = game:GetService("Players")[SelectPlayer].Character.HumanoidRootPart.CFrame * CFrame.new(0,-DistanceFarm,0) * CFrame.Angles(math.rad(90),0,0)
elseif MethodFarm == "Upper" then
game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = game:GetService("Players")[SelectPlayer].Character.HumanoidRootPart.CFrame * CFrame.new(0,DistanceFarm,0) * CFrame.Angles(math.rad(-90),0,0)
else
game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = game:GetService("Players")[SelectPlayer].Character.HumanoidRootPart.CFrame  * CFrame.new(0,0,DistanceFarm) * CFrame.Angles(math.rad(0),0,0)
end
local args = {
    [1] = {
        ["Mobile"] = true,
        ["Goal"] = "LeftClick"
    }
}

game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))
if Skill1 then
        game:service('VirtualInputManager'):SendKeyEvent(true, "One", false, game)
        game:service('VirtualInputManager'):SendKeyEvent(false, "One", false, game)
end
if Skill2 then
        game:service('VirtualInputManager'):SendKeyEvent(true, "Two", false, game)
        game:service('VirtualInputManager'):SendKeyEvent(false, "Two", false, game)
end
if Skill3 then
        game:service('VirtualInputManager'):SendKeyEvent(true, "Three", false, game)
        game:service('VirtualInputManager'):SendKeyEvent(false, "Three", false, game)
end
if Skill4 then
        game:service('VirtualInputManager'):SendKeyEvent(true, "Four", false, game)
        game:service('VirtualInputManager'):SendKeyEvent(false, "Four", false, game)
end
if AutoUseUltimate then
        game:service('VirtualInputManager'):SendKeyEvent(true, "G", false, game)
        game:service('VirtualInputManager'):SendKeyEvent(false, "G", false, game)
end
if AutoSafe then
    if game.Players.LocalPlayer.Character.Humanoid.Health <= 50 then
           game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(1023.8338012695312, 439.51055908203125, -1324.156494140625)
    end
end
end)
end
end
end)

spawn(function()
while wait() do
if AutoFarmWeakestDummy then
pcall(function()
if MethodFarm == "Behind" then
game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = game.Workspace.Live["Weakest Dummy"].HumanoidRootPart.CFrame * CFrame.new(0,0,DistanceFarm) * CFrame.Angles(math.rad(0),0,0)
elseif MethodFarm == "Below" then
game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = game.Workspace.Live["Weakest Dummy"].HumanoidRootPart.CFrame * CFrame.new(0,-DistanceFarm,0) * CFrame.Angles(math.rad(90),0,0)
elseif MethodFarm == "Upper" then
game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = game.Workspace.Live["Weakest Dummy"].HumanoidRootPart.CFrame * CFrame.new(0,DistanceFarm,0) * CFrame.Angles(math.rad(-90),0,0)
else
game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = game.Workspace.Live["Weakest Dummy"].HumanoidRootPart.CFrame * CFrame.new(0,0,DistanceFarm) * CFrame.Angles(math.rad(0),0,0)
end
local args = {
    [1] = {
        ["Mobile"] = true,
        ["Goal"] = "LeftClick"
    }
}

game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))
if Skill1 then
        game:service('VirtualInputManager'):SendKeyEvent(true, "One", false, game)
        game:service('VirtualInputManager'):SendKeyEvent(false, "One", false, game)
end
if Skill2 then
        game:service('VirtualInputManager'):SendKeyEvent(true, "Two", false, game)
        game:service('VirtualInputManager'):SendKeyEvent(false, "Two", false, game)
end
if Skill3 then
        game:service('VirtualInputManager'):SendKeyEvent(true, "Three", false, game)
        game:service('VirtualInputManager'):SendKeyEvent(false, "Three", false, game)
end
if Skill4 then
        game:service('VirtualInputManager'):SendKeyEvent(true, "Four", false, game)
        game:service('VirtualInputManager'):SendKeyEvent(false, "Four", false, game)
end
if AutoUseUltimate then
        game:service('VirtualInputManager'):SendKeyEvent(true, "G", false, game)
        game:service('VirtualInputManager'):SendKeyEvent(false, "G", false, game)
end
if AutoSafe then
    if game.Players.LocalPlayer.Character.Humanoid.Health <= 50 then
           game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(1023.8338012695312, 439.51055908203125, -1324.156494140625)
    end
end
end)
end
end
end)

spawn(function()
while wait() do
if AutoFarmCrabBossReal then
pcall(function()
if MethodFarm == "Behind" then
game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = game.Workspace.Live["Crab Boss"].HumanoidRootPart.CFrame * CFrame.new(0,0,DistanceFarm) * CFrame.Angles(math.rad(0),0,0)
elseif MethodFarm == "Below" then
game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = game.Workspace.Live["Crab Boss"].HumanoidRootPart.CFrame * CFrame.new(0,-DistanceFarm,0) * CFrame.Angles(math.rad(90),0,0)
elseif MethodFarm == "Upper" then
game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = game.Workspace.Live["Crab Boss"].HumanoidRootPart.CFrame * CFrame.new(0,DistanceFarm,0) * CFrame.Angles(math.rad(-90),0,0)
else
game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = game.Workspace.Live["Crab Boss"].HumanoidRootPart.CFrame * CFrame.new(0,0,DistanceFarm) * CFrame.Angles(math.rad(0),0,0)
end
local args = {
    [1] = {
        ["Mobile"] = true,
        ["Goal"] = "LeftClick"
    }
}

game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))
if Skill1 then
        game:service('VirtualInputManager'):SendKeyEvent(true, "One", false, game)
        game:service('VirtualInputManager'):SendKeyEvent(false, "One", false, game)
end
if Skill2 then
        game:service('VirtualInputManager'):SendKeyEvent(true, "Two", false, game)
        game:service('VirtualInputManager'):SendKeyEvent(false, "Two", false, game)
end
if Skill3 then
        game:service('VirtualInputManager'):SendKeyEvent(true, "Three", false, game)
        game:service('VirtualInputManager'):SendKeyEvent(false, "Three", false, game)
end
if Skill4 then
        game:service('VirtualInputManager'):SendKeyEvent(true, "Four", false, game)
        game:service('VirtualInputManager'):SendKeyEvent(false, "Four", false, game)
end
if AutoUseUltimate then
        game:service('VirtualInputManager'):SendKeyEvent(true, "G", false, game)
        game:service('VirtualInputManager'):SendKeyEvent(false, "G", false, game)
end
if AutoSafe then
    if game.Players.LocalPlayer.Character.Humanoid.Health == 50 then
           game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(1023.8338012695312, 439.51055908203125, -1324.156494140625)
    end
end
end)
end
end
end)

spawn(function()
    while wait(2) do
        if ESPPlayer then
            UpdatePlayerChams()
        end
    end
end)

spawn(function()
while wait() do
if InfiniteJump then
pcall(function()
local player = game:GetService("Players").LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()

local humanoid = character:WaitForChild("Humanoid")

local canJump = true

local UIS = game:GetService("UserInputService")
UIS.InputBegan:Connect(function(input)
    -- Check if spacebar is pressed and canJump is true
    if input.KeyCode == Enum.KeyCode.Space and canJump then
        humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
        canJump = false
    end
end)

humanoid.StateChanged:Connect(function(_, state)
    if state == Enum.HumanoidStateType.Landed then
        canJump = true
    end
end)
end)
end
end
end)

spawn(function()
while wait() do
if InfiniteJump then
pcall(function()
local player = game:GetService("Players").LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()

local humanoid = character:WaitForChild("Humanoid")

local canJump = true

local UIS = game:GetService("UserInputService")
local jumpButton = UIS.TouchTapInWorld

local function onScreenTapped()
    if canJump then
        humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
        canJump = false
    end
end

humanoid.StateChanged:Connect(function(_, state)
    if state == Enum.HumanoidStateType.Landed then
        canJump = true
    end
end)

-- Connect the jump function to touch input on mobile
jumpButton:Connect(onScreenTapped)
end)
end
end
end)

spawn(function()
while wait() do
if Flyyy then
pcall(function()
fly()
end)
end
end
end)

spawn(function()
while wait() do
if TeleportPlayer then
pcall(function()
if MethodFarm == "Behind" then
game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = game:GetService("Players")[SelectPlayer].Character.HumanoidRootPart.CFrame * CFrame.new(0,0,DistanceFarm) * CFrame.Angles(math.rad(0),0,0)
elseif MethodFarm == "Below" then
game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = game:GetService("Players")[SelectPlayer].Character.HumanoidRootPart.CFrame * CFrame.new(0,-DistanceFarm,0) * CFrame.Angles(math.rad(90),0,0)
elseif MethodFarm == "Upper" then
game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = game:GetService("Players")[SelectPlayer].Character.HumanoidRootPart.CFrame * CFrame.new(0,DistanceFarm,0) * CFrame.Angles(math.rad(-90),0,0)
else
game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = game:GetService("Players")[SelectPlayer].Character.HumanoidRootPart.CFrame  * CFrame.new(0,0,DistanceFarm) * CFrame.Angles(math.rad(0),0,0)
end
end)
end
end
end)